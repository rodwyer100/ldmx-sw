"""Configuration for HGCROC Emulator"""

class HgcrocEmulator() :
    """Configuration for HGCROC Emulator

    Parameters
    ----------
    mipEnergy : float
        Energy of a MIP in the detector [MeV]
    nElectronsPerMIP : float
        Number of electrons generated by a MIP
    isEcal : bool
        Are we emulating in the ecal?

    Attributes
    ----------
    pedestal : float
    clockCycle : float
    timingJitter : float
    readoutPadCapacitance : float
    maxADCRange : float
    nADCs : float
    iSOI : float
    nElectronsPerMIP : float
    mipSiEnergy : float
    mVperMIP : float
    MeV : float
    gain : float
    nEcalLayers : int
    nModulesPerLayer : int
    nCellsPerModule : int
    ecal : bool
    noiseRMS : float
    readoutThreshold : float
    toaThreshold : float
    totThreshold : float
    """

    def __init__(self, mipEnergy , nElectronsPerMIP, isEcal) :

        #######################################################################
        # Settings of the chip
        self.pedestal = 50. #ADC counts - baseline factor to subtract off of readout
        self.clockCycle = 25.0 #ns
        self.timingJitter = self.clockCycle / 100. #ns - pretty arbitrarily chosen
        self.readoutPadCapacitance = 0.1 #pF <- derived from hardware of HGCROC
        self.maxADCRange = 320. #fC <- setting of HGCROC
        self.nADCs = 10 
        self.iSOI  = 0 


        #Voltage -> ADC Counts conversion
        # voltage [mV] / gain = ADC Counts
        #
        # gain = maximum ADC range [fC] ( 1 / readout pad capacitance in pF ) ( 1 / 2^10 ADC Counts ) = mV / ADC counts
        self.gain = self.maxADCRange/self.readoutPadCapacitance/1024 # mV / ADC

        #######################################################################
        # Physical Constants for Detector Materials

        # ecal hexagon geometry parameters
        # used for putting noise into empty channels
        self.nEcalLayers      = 34
        self.nModulesPerLayer = 7
        self.nCellsPerModule  = 397
        self.ecal = isEcal

        # define member variables that will be calculated below
        self.mVperMeV         = 0. #mV/MeV - default that breaks digitization
        self.noiseRMS         = 0. #mV - useless default
        self.readoutThreshold = 0. #mV - useless default
        self.toaThreshold     = 0. #mV - useless default
        self.totThreshold     = 0. #mV - useless default

        # calculate member variables depending on input parameters
        self.setNoise( 700. , 25. ) #depends on readoutPadCapacitance
        self.setEnergyToVoltage( #depends on readoutPadCapacitance
                            mipEnergy
                            , nElectronsPerMIP
                            )
        self.setThresholdDefaults(nElectronsPerMIP) #depends on gain, pedestal, noiseRMS, and readoutPadCapacitance

    def calculateVoltage(self, electrons) :
        """Calculate the voltage signal [mV] of the input number of electrons

        Uses the charge of 1000 electrons in fC and the capacitance of the readout pads.

        electrons ( 0.162 fC / 1000 electrons ) ( 1 / capacitance in pF ) = voltage [mV]

        Parameters
        ----------
        electrons : int
            Number of electrons (or e-h pairs) produced
        """

        return electrons*(0.162/1000.)*(1./self.readoutPadCapacitance)
    
    def setNoise(self, noiseIntercept , noiseSlope ) :
        """Calculate the Noise RMS [mV] from the capacitance of the readout pads.

        Parameters
        ----------
        noiseIntercept : float
            Noise when there is no capacitance
        noiseSlope : float
            Ratio of noise in electrons to capacitance in pF of pads
        """

        self.noiseRMS = self.calculateVoltage(noiseIntercept + noiseSlope*self.readoutPadCapacitance)

    def setEnergyToVoltage(self , mipEnergy , nElectronsPerMIP ) :
        """Calculate the conversion between energy [MeV] and voltage [mV]

        ( 1 MIP / energy per MIP [MeV] ) ( voltage per MIP [mV] / 1 MIP ) = voltage [mV] / energy [MeV]

        Parameters
        ----------
        mipEnergy : float
            Energy of a MIP in the detector [MeV]
        nElectronsPerMIP : float
            Number of electrons generated by a MIP
        """

        self.mVperMeV = (1./mipEnergy)*self.calculateVoltage( nElectronsPerMIP )

    def setThresholdDefaults(self, nElectronsPerMIP):
        """Set the different thresholds of the chip

        The default calculation for the different thresholds if the following:
        - readout is 4 times the rms noise above the pedestal 
        - toa is 5 MIPs above the pedestal
        - tot is 50 MIPs above the pedestal

        These calculations depend on the following parameters;
        the user should call this function _after_ setting these parameters.
        - noiseRMS
        - pedestal
        - gain
        - readoutPadCapacitance

        Parameters
        ----------
        nElectronsPerMIP : int
            Number of electrons generated by a MIP
        """

        self.readoutThreshold = self.gain*self.pedestal + 4*self.noiseRMS
        self.toaThreshold = self.gain*self.pedestal + self.calculateVoltage( 5.*self.nElectronsPerMIP )
        self.totThreshold = self.gain*self.pedestal + self.calculateVoltage( 50.*self.nElectronsPerMIP )

    def forECal() :
        """Generate a chip emulator for the ECal settings"""

        return HgcrocEmulator(
                    0.130 #MeV - corresponds to ~3.5 eV per e-h pair <- derived from 0.5mm thick Si
                    , 37000 #e-h pairs created per MIP <- derived from 0.5mm thick Si
                    , True
                   )

    def forHCal() :
        """Generate a chip emulator for the HCal settings"""

        return HgcrocEmulator(
                    0.130 #MeV - corresponds to ~3.5 eV per e-h pair <- derived from 0.5mm thick Si
                    , 37000 #e-h pairs created per MIP <- derived from 0.5mm thick Si
                    , False
                   )
